## 一、面向对象编程基础

活在当下的程序员应该都听过&quot;面向对象编程&quot;一词，也经常有人问能不能用一句话解释下什么是&quot;面向对象编程&quot;，我们先来看看比较正式的说法。

&quot;把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的**封装（encapsulation）**隐藏内部细节，通过**继承（inheritance）**实现类的特化（specialization）和泛化（generalization），通过**多态（polymorphism）**实现**基于对象类型的动态分派**。&quot;

这样一说是不是更不明白了。所以我们还是看看更通俗易懂的说法，下面这段内容来自于[知乎](https://www.zhihu.com/)。

![](./res/oop-zhihu.png)

> **说明：** 以上的内容来自于网络，不代表作者本人的观点和看法，与作者本人立场无关，相关责任不由作者承担。

之前我们说过&quot;**程序是指令的集合**&quot;，我们在程序中书写的语句在执行时会变成一条或多条指令然后由CPU去执行。

当然为了简化程序的设计，我们引入了函数的概念，**把相对独立且经常重复使用的代码放置到函数中**，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。

但是说了这么多，不知道大家是否发现，所谓编程就是**程序员按照计算机的工作方式控制计算机完成各种任务**。但是，计算机的工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，&quot;每个人都应该学习编程&quot;这样的豪言壮语就只能说说而已。

当然，这些还不是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变得举步维艰，所以在上世纪60年代末期，&quot;[软件危机](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA)&quot;、&quot;[软件工程](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B)&quot;等一系列的概念开始在行业中出现。

当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的&quot;[银弹](https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9)&quot;，真正让软件开发者看到希望的是上世纪70年代诞生的[Smalltalk](https://zh.wikipedia.org/wiki/Smalltalk)编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的[Simula](https://zh.wikipedia.org/wiki/Simula)语言）。

按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为“对象”，而我们解决问题的方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出复杂的系统来解决现实中的问题。

> **说明：** **<font color="red">当然面向对象也不是解决软件开发中所有问题的最后的<font color="blue">“银弹”</font>，所以今天的高级程序设计语言几乎都<font color="blue">提供了对多种编程范式</font>的支持</font>**，Python也不例外。
>
> 高级编程语言通常支持多种编程范式，包括但不限于以下几种：
>
> 1. **命令式编程（Imperative Programming）**：这种范式关注计算机的状态变化和控制流程，以指令的形式描述计算机执行的具体步骤。C语言和Java语言是命令式编程的典型代表。
> 2. **面向对象编程（Object-Oriented Programming, OOP）**：OOP将程序组织为对象的集合，强调数据和操作的封装、继承和多态。Java、C++和Python都是支持面向对象编程的语言。
> 3. **函数式编程（Functional Programming）**：函数式编程将计算视为数学函数的求值，强调使用纯函数、不可变数据和高阶函数。Haskell、Clojure和Scala是支持函数式编程的语言。
> 4. **声明式编程（Declarative Programming）**：声明式编程以描述问题的本质和解决方案的逻辑为重点，而非具体的计算步骤。SQL和HTML/CSS可以看作是声明式语言的例子。
> 5. **反应式编程（Reactive Programming）**：反应式编程处理异步数据流和变化的传播，适用于事件驱动应用程序和流式数据处理应用程序。JavaScript等语言通过其库和框架支持反应式编程。
> 6. **并发编程（Concurrent Programming）**：并发编程允许同时执行多个任务或进程，以提高性能和资源利用率。多线程服务器、并行处理、并发网络服务器和高性能计算等应用都涉及到并发编程。
> 7. **范型编程（Generic Programming）**：范型编程旨在创建可重用、灵活和类型无关的代码。它允许编写算法和数据结构，而无需指定其操作类型。C++的模板和Java的泛型是范型编程的例子。
>
> 总的来说，这些编程范式各有特点，适用于不同的编程场景和问题。高级编程语言通常不局限于单一的编程范式，而是提供了多种范式的支持，以便程序员可以根据需要选择最适合解决问题的方法。

Python 支持多种编程范式，包括：

1. **过程化编程**：Python 允许开发者定义函数来执行特定任务，并使用过程化技术来结构化程序。这种范式侧重于将程序划分为一组过程或函数。
2. **面向对象编程（OOP）**：Python 完全支持 OOP，提供了类、对象、继承和多态等特性。OOP 是一种围绕对象组织代码的范式，对象是类的实例。
3. **命令式编程**：作为一种通用编程语言，Python 默认支持命令式编程。这种范式涉及编写代码来指定计算机按照详细步骤进行操作。
4. **事件驱动编程**：Python 提供了诸如 Tkinter 和 asyncio 等库，使得事件驱动编程成为可能。这种范式常用于图形用户界面（GUI）和网络编程。
5. **函数式编程**：Python 支持函数式编程概念，如高阶函数、lambda 函数和列表推导。函数式编程强调不可变性和纯函数的使用。

总的来说，Python 的灵活性在于它不仅支持多种编程范式，而且还允许混合使用这些范式。这使得 Python 成为一种非常强大且适用于各种编程任务的语言。



### 1.1 类和对象

简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，**类是抽象的概念，而对象是具体的东西**。

在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且**对象一定属于某个类（型）**。当我们把一大堆拥有共同特征的对象的**静态特征（属性）**和**动态特征（行为）**都抽取出来后，就可以定义出一个叫做“类”的东西。

![](./res/object-feature.png)



### 1.2 定义类

在Python中可以使用`class`关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。

**`__init__`是一个特殊方法用于在创建对象时进行初始化操作**。

使用`__init__()` 方法，其作用：实例化对象时，连带其中的参数，会一并传给``__init__``函数自动并执行它。

`__init__()`函数的参数列表会在开头多出一项，它**永远指代新建的那个实例对象**，Python语法要求这个参数必须要有，名称为self。

```Python
class Student(object):

    # __init__是一个特殊方法用于在创建对象时进行初始化操作
    # 通过这个方法我们可以为学生对象绑定name和age两个属性
    def __init__(self, name, age):
      	# 赋予name属性、age属性给实例化对象本身
        # self.实例化对象属性 = 参数
        self.name = name
        self.age = age

    def study(self, course_name):
        print('%s正在学习%s.' % (self.name, course_name))

    # PEP 8要求标识符的名字用全小写多个单词用下划线连接
    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)
    def watch_movie(self):
        if self.age < 18:
            print('%s只能观看《熊出没》.' % self.name)
        else:
            print('%s正在观看青春爱情大电影.' % self.name)
```

> **说明：** 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。



在Python中，`__xxx__()`的函数叫做**魔法方法**，指的是具有==特殊功能==的函数。

> ① \__init__()方法，**在创建一个对象时默认被调用，不需要手动调用**。
>
> ② \__init__(self)中的self参数，不需要开发者传递，python解释器会自动把**当前实例对象的引用**传递过去。



**\__str__()方法**（魔法方法）

当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了`__str__`方法，那么就会**自动打印**从在这个方法中 return 的数据。

```py
# 1、定义一个类
class Car():
    # 首先定义一个__init__方法，用于初始化实例对象属性
    def __init__(self, brand, model, color):
        self.brand = brand
        self.model = model
        self.color = color

    # 定义一个__str__内置魔术方法，用于输出小汽车的相关信息
    def __str__(self):
        return f'汽车品牌：{self.brand}，汽车型号：{self.model}，汽车颜色：{self.color}'

# 2、实例化对象c1
c1 = Car('奔驰', 'S600', '黑色')
print(c1)
```

> ① `__str__`这个魔术方法是在类的外部，使用print(对象)时，**自动被调用的**。
>
> ② 在类的内部定义`__str__`方法时，必须使用return返回一个字符串类型的数据，否则报错？。



**`__del__()`方法**（删除方法或析构方法）

当删除对象时，python解释器也会默认调用`__del__()`方法。

```py
class Person():
    # 构造函数__init__
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    # 析构方法__del__
    def __del__(self):
        print(f'{self}对象已经被删除')

# 实例化对象
p1 = Person('白骨精', 100)
# 删除对象p1
del p1
```

> `__del__()`方法在使用过程中，比较简单，但是其在实际开发中，有何作用呢？
>
> 答：主要用于**关闭文件操作、关闭数据库连接**等等。



**总结：**

提到魔术方法：① 这个方法在什么情况下被触发 ② 这个方法有什么实际的作用

`__init__()`：初始化方法或者称之为“构造函数”，**在类实例化时自动执行初始化对象**，其主要作用就是在对象初始化时，对对象进行初始化操作（如赋予属性）

`__str__()`：对象字符串方法，当我们在类的外部，使用print方法输出对象时被触发，其主要功能就是对对象进行打印输出操作，要求方法必须使用return返回字符串格式的数据。

`__del__()`：删除方法或者称之为“析构方法”，在对象被del删除时触发，其主要作用就是适用于**关闭文件、关闭数据库连接**等等。





### 1.3 创建和使用对象

当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。

```Python
def main():
    # 创建学生对象并指定姓名和年龄
    stu1 = Student('骆昊', 38)
    # 给对象发study消息
    stu1.study('Python程序设计')
    # 给对象发watch_movie消息
    stu1.watch_movie()
    stu2 = Student('王大锤', 15)
    stu2.study('思想品德')
    stu2.watch_movie()


if __name__ == '__main__':
    main()
```



### 1.4 访问可见性问题

对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给`Student`对象绑定的`name`和`age`属性到底具有怎样的访问权限（也称为可见性）。

因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。

**在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的**，如果希望属性是**私有的，在给属性命名时可以用两个下划线作为开头**，下面的代码可以验证这一点。

```Python
class Test:

    def __init__(self, foo):
        self.__foo = foo

    def __bar(self):
        print(self.__foo)
        print('__bar')


def main():
    test = Test('hello')
    
    # AttributeError: 'Test' object has no attribute '__bar'
    test.__bar()
    # AttributeError: 'Test' object has no attribute '__foo'
    print(test.__foo)


if __name__ == "__main__":
    main()
```

但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上**如果你知道更换名字的规则的话，你仍然可以访问到它们**，下面的代码就可以验证这一点。

之所以这样设定，可以用这样一句名言加以解释，就是&quot;**We are all consenting adults here**&quot;。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。

```Python
class Test:

    def __init__(self, foo):
        self.__foo = foo

    def __bar(self):
        print(self.__foo)
        print('__bar')


def main():
    test = Test('hello')
    test._Test__bar()
    print(test._Test__foo)


if __name__ == "__main__":
    main()
```

**在实际开发中，我们并不建议将属性设置为私有的**，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是**让属性名以单下划线开头来表示属性是受保护的**，本类之外的代码在访问这样的属性时应该要保持慎重。

**这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的**，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的[《Python - 那些年我们踩过的那些坑》](http://blog.csdn.net/jackfrued/article/details/79521404)文章中的讲解。



### 1.5 面向对象的支柱

面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。

我自己对封装的理解是&quot;隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口&quot;。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们**只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）**。



### 1.6 练习

#### 练习1：定义一个类描述数字时钟。

参考答案：

```Python
from time import sleep


class Clock(object):
    """数字时钟"""

    def __init__(self, hour=0, minute=0, second=0):
        """初始化方法

        :param hour: 时
        :param minute: 分
        :param second: 秒
        """
        self._hour = hour
        self._minute = minute
        self._second = second

    def run(self):
        """走字"""
        self._second += 1
        if self._second == 60:
            self._second = 0
            self._minute += 1
            if self._minute == 60:
                self._minute = 0
                self._hour += 1
                if self._hour == 24:
                    self._hour = 0

    def show(self):
        """显示时间"""
        return '%02d:%02d:%02d' %(self._hour, self._minute, self._second)


def main():
    clock = Clock(23, 59, 58)
    while True:
        print(clock.show())
        sleep(1)
        clock.run()


if __name__ == '__main__':
    main()
```



#### 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。

参考答案：

```Python
from math import sqrt


class Point(object):

    def __init__(self, x=0, y=0):
        """初始化方法
        
        :param x: 横坐标
        :param y: 纵坐标
        """
        self.x = x
        self.y = y

    def move_to(self, x, y):
        """移动到指定位置
        
        :param x: 新的横坐标
        "param y: 新的纵坐标
        """
        self.x = x
        self.y = y

    def move_by(self, dx, dy):
        """移动指定的增量
        
        :param dx: 横坐标的增量
        "param dy: 纵坐标的增量
        """
        self.x += dx
        self.y += dy

    def distance_to(self, other):
        """计算与另一个点的距离
        
        :param other: 另一个点
        """
        dx = self.x - other.x
        dy = self.y - other.y
        return sqrt(dx ** 2 + dy ** 2)

    def __str__(self):
        return '(%s, %s)' % (str(self.x), str(self.y))


def main():
    p1 = Point(3, 5)
    p2 = Point()
    print(p1)
    print(p2)
    p2.move_by(-1, 2)
    print(p2)
    print(p1.distance_to(p2))


if __name__ == '__main__':
    main()
```

> **说明：** 本章中的插图来自于Grady Booch等著作的[《面向对象分析与设计》](https://item.jd.com/20476561918.html)一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。